import numpy as npimport cv2from PIL import ImageRIGHT_PATH = 'dataset/112_R.png'LEFT_PATH = 'dataset/112_L.png'right_image = cv2.imread(RIGHT_PATH, 0)left_image = cv2.imread(LEFT_PATH, 0)M = 4N = 4STRIDE = 1MAX_STRIDE = 100THRESHOLD = 0.99975EPSILON = 0.00000001height, width = right_image.shape[:2]window_size = [2 * M + 1, 2 * N + 1]right_image = cv2.copyMakeBorder(right_image, top=M, bottom=M, left=N, right=N, borderType=cv2.BORDER_CONSTANT, value=0)left_image = cv2.copyMakeBorder(left_image, top=M, bottom=M, left=N, right=N, borderType=cv2.BORDER_CONSTANT, value=0)disparity_matrix = []print("Analyzing images...")for y in range(0, height - M, STRIDE):    percentage = y/height*100    print("\r completed: ".format(percentage) + str(int(percentage)) + "%", end="")    disparity = []    for x in range(0, width - N, STRIDE):        # Create a sliding window        right_window = right_image[y:y + window_size[0], x:x + window_size[1]]        # Reshape the windows into vectors        right_window = np.reshape(right_window, -1)        # Compute the mean of the vectors        right_mean = np.mean(right_window)        # Normalize the vectors        normalized_right_window = np.subtract(right_window, right_mean)        # Compute the second order norm of the normalized vector        right_norm = np.linalg.norm(normalized_right_window)        # Avoid divisions by zero        if right_norm == 0:            right_norm = EPSILON        max_correlation = 0        match_distance = 0        for distance in range(x, min(x+MAX_STRIDE, width - N), STRIDE):            left_window = left_image[y:y + window_size[0], distance:distance + window_size[1]]            left_window = np.reshape(left_window, -1)            left_mean = np.mean(left_window)            normalized_left_window = np.subtract(left_window, left_mean)            left_norm = np.linalg.norm(normalized_left_window)            # Avoid divisions by zero            if left_norm == 0:                left_norm = EPSILON            # Compute the correlation            correlation = np.matmul((normalized_left_window / left_norm), (normalized_right_window / right_norm))            # Store maximum correlation value            if correlation > max_correlation:                max_correlation = correlation                match_distance = distance - x            # Skip loop when close to match            if max_correlation >= THRESHOLD:                break        # Add best value to row        disparity.append(match_distance)    # Add row to matrix    disparity_matrix.append(disparity)# Transform in numpy array and normalize to [0,255]disparity_matrix = np.array(disparity_matrix, dtype=float)disparity_matrix = disparity_matrix / np.max(disparity_matrix) * 255# Show image with PIL and save it as pngimage = Image.fromarray(disparity_matrix)image = image.convert('L')image.show()NAME = 'test_result1.png'image.save(NAME)print("Image saved with name: " + NAME)