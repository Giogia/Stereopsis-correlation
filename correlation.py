import numpy as npimport cv2from PIL import ImageRIGHT_PATH = 'dataset/109_R.png'LEFT_PATH = 'dataset/109_L.png'right_image = cv2.imread(RIGHT_PATH, 0)left_image = cv2.imread(LEFT_PATH, 0)height, width = right_image.shape[:2]RESOLUTION: int = 500m = max(int(height / RESOLUTION), 1)n = max(int(width / RESOLUTION), 1)window_size = [2 * m + 1, 2 * n + 1]print(window_size)STRIDE = 1MAX_STRIDE = int(RESOLUTION)THRESHOLD = 0.99975right_image = cv2.copyMakeBorder(right_image, top=m, bottom=m, left=n, right=n, borderType=cv2.BORDER_CONSTANT, value=0)left_image = cv2.copyMakeBorder(left_image, top=m, bottom=m, left=n, right=n, borderType=cv2.BORDER_CONSTANT, value=0)disparity_matrix = []for y in range(0, height - m, STRIDE):    print("line:" + str(y))    disparity = []    for x in range(0, width - n, STRIDE):        # Create a sliding window        right_window = right_image[y:y + window_size[0], x:x + window_size[1]]        # Reshape the windows into vectors        right_window = np.reshape(right_window, -1)        # Compute the mean of the vectors        right_mean = np.mean(right_window)        # Normalize the vectors        normalized_right_window = np.subtract(right_window, right_mean)        # Compute the second order norm of the normalized vector        right_norm = np.linalg.norm(normalized_right_window)        max_correlation = 0        match_distance = 0        for distance in range(x, min(MAX_STRIDE, width - n), STRIDE):            left_window = left_image[y:y + window_size[0], distance:distance + window_size[1]]            left_window = np.reshape(left_window, -1)            left_mean = np.mean(left_window)            normalized_left_window = np.subtract(left_window, left_mean)            left_norm = np.linalg.norm(normalized_left_window)            # Compute the correlation            correlation = np.matmul((normalized_left_window / left_norm), (normalized_right_window / right_norm))            # Store maximum correlation value            if correlation > max_correlation:                max_correlation = correlation                match_distance = distance - x            # Skip loop when close to match            if max_correlation >= THRESHOLD:                break        # Add best value to row        disparity.append(match_distance)    # Add row to matrix    disparity_matrix.append(disparity)# Transform in numpy array and normalize to [0,255]disparity_matrix = np.array(disparity_matrix, dtype=float)disparity_matrix = disparity_matrix / np.max(disparity_matrix) * 255# Show image with PIL (for problems with opencv imshowimage = Image.fromarray(disparity_matrix)image.show()